import dataclass_wizard.bases
import datetime
from _typeshed import Incomplete
from dataclass_wizard.bases import AbstractMeta as AbstractMeta, BaseLoadHook as BaseLoadHook
from dataclass_wizard.class_helper import create_meta as create_meta, create_new_class as create_new_class, get_meta as get_meta, is_subclass_safe as is_subclass_safe, resolve_dataclass_field_to_alias_for_load as resolve_dataclass_field_to_alias_for_load, set_class_loader as set_class_loader
from dataclass_wizard.decorators import process_patterned_date_time as process_patterned_date_time, setup_recursive_safe_function as setup_recursive_safe_function, setup_recursive_safe_function_for_generic as setup_recursive_safe_function_for_generic
from dataclass_wizard.enums import KeyAction as KeyAction, KeyCase as KeyCase
from dataclass_wizard.errors import JSONWizardError as JSONWizardError, MissingData as MissingData, MissingFields as MissingFields, ParseError as ParseError, UnknownKeysError as UnknownKeysError
from dataclass_wizard.models import Extras as Extras, PatternBase as PatternBase, TypeInfo as TypeInfo
from dataclass_wizard.type_conv import as_date as as_date, as_datetime as as_datetime, as_int as as_int, as_time as as_time, as_timedelta as as_timedelta
from dataclass_wizard.type_def import T as T, JSONObject
from dataclass_wizard.utils._dataclass_compat import dataclass_fields as dataclass_fields, dataclass_init_field_names as dataclass_init_field_names, dataclass_init_fields as dataclass_init_fields, dataclass_kw_only_init_field_names as dataclass_kw_only_init_field_names, set_new_attribute as set_new_attribute
from dataclass_wizard.utils._function_builder import FunctionBuilder as FunctionBuilder
from dataclass_wizard.utils._object_path import safe_get as safe_get
from dataclass_wizard.utils._string_conv import possible_json_keys as possible_json_keys
from dataclass_wizard.utils._typing_compat import eval_forward_ref_if_needed as eval_forward_ref_if_needed, get_keys_for_typed_dict as get_keys_for_typed_dict, get_origin_v2 as get_origin_v2, is_annotated as is_annotated, is_typed_dict as is_typed_dict, is_typed_dict_type_qualifier as is_typed_dict_type_qualifier, is_union as is_union
from dataclasses import Field
from datetime import date
from typing import Callable, ClassVar

LEAF_TYPES: frozenset
UTC: datetime.timezone
TRUTHY_VALUES: frozenset
CLASS_TO_LOAD_FUNC: dict
CLASS_TO_LOADER: dict
CATCH_ALL: str
TAG: str
PY311_OR_ABOVE: bool
PACKAGE_NAME: str
_LOAD_HOOKS: str

class LoadMixin(dataclass_wizard.bases.BaseLoadHook):
    transform_json_field: ClassVar[None] = ...
    __LOAD_HOOKS__: ClassVar[dict] = ...
    @classmethod
    def __init_subclass__(cls, **kwargs): ...
    @staticmethod
    def load_fallback(tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def is_none(tp: TypeInfo, extras: Extras) -> str: ...
    @classmethod
    def load_to_str(cls, tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_int(tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_float(tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_bool(tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_bytes(tp: TypeInfo, extras: Extras): ...
    @classmethod
    def load_to_bytearray(cls, tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_none(tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_enum(tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_uuid(tp: TypeInfo, extras: Extras): ...
    @classmethod
    def load_to_iterable(cls, tp: TypeInfo, extras: Extras): ...
    @classmethod
    def load_to_tuple(cls, tp: TypeInfo, extras: Extras): ...
    @classmethod
    def load_to_named_tuple(cls, tp: TypeInfo, extras: Extras): ...
    @classmethod
    def _load_to_named_tuple_fn(cls, _cls, tp: TypeInfo, extras: Extras): ...
    @classmethod
    def load_to_named_tuple_untyped(cls, tp: TypeInfo, extras: Extras): ...
    @classmethod
    def _build_dict_comp(cls, tp, v, i_next, k_next, v_next, kt, vt, extras): ...
    @classmethod
    def load_to_dict(cls, tp: TypeInfo, extras: Extras): ...
    @classmethod
    def load_to_defaultdict(cls, tp: TypeInfo, extras: Extras): ...
    @classmethod
    def load_to_typed_dict(cls, tp: TypeInfo, extras: Extras): ...
    @classmethod
    def _load_to_typed_dict_fn(cls, _cls, tp: TypeInfo, extras: Extras): ...
    @classmethod
    def load_to_union(cls, _cls, tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_literal(tp: TypeInfo, extras: Extras, _cls: Incomplete | None = ...): ...
    @staticmethod
    def load_to_decimal(tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_path(tp: TypeInfo, extras: Extras): ...
    @classmethod
    def load_to_date(cls, tp: TypeInfo, extras: Extras): ...
    @classmethod
    def load_to_datetime(cls, tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_time(tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def _load_to_date(tp: TypeInfo, extras: Extras, cls: type[date] | type[datetime]): ...
    @staticmethod
    def load_to_timedelta(tp: TypeInfo, extras: Extras): ...
    @staticmethod
    def load_to_dataclass(tp: TypeInfo, extras: Extras, _cls: Incomplete | None = ...): ...
    @classmethod
    def load_dispatcher_for_annotation(cls, tp, extras): ...
def setup_default_loader(cls: type[LoadMixin] = ...): ...
def check_and_raise_missing_fields(_locals, o, cls, fields: tuple[Field, ...] | None, **kwargs): ...
def load_func_for_dataclass(cls: type, extras: Extras | None = ..., loader_cls: type[LoadMixin] = ..., base_meta_cls: type = ...) -> Callable[[JSONObject], T] | None: ...
def generate_field_code(cls_loader: LoadMixin, extras: Extras, field: Field, field_i: int, var_name: Incomplete | None = ...) -> str | TypeInfo: ...
def re_raise(e, cls, o, fields, field, value): ...
def get_loader(class_or_instance: Incomplete | None = ..., create: bool = ..., base_cls: T = ...) -> type[T]: ...
def fromdict(cls: type[T], d: JSONObject) -> T: ...
def fromlist(cls: type[T], list_of_dict: list[JSONObject]) -> list[T]: ...
